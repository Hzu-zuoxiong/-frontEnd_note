# 浏览器缓存

## 概述：

浏览器缓存就是把一个已请求过的 Web 资源拷贝一份副本储存在浏览器中。当下一次请求到来的时候，如果是相同的 URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个 URL 地址的时候，如果网页更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已更新，浏览器才会再次下载网页。

## 规则：

- 新鲜度：含有完整的过期时间控制头信息（HTTP 协议报头），并且仍在有效期内。或浏览器已经使用过这个缓存副本，并且在一个会话中已检查过新鲜度。满足以上两者之一，浏览器会直接从缓存中获取副本并渲染。
- 校验值：服务器返回资源的时候有时在控制头信息带上这个资源的实体标签 Etag，可以用来作为浏览器再次请求过程的校验标识。如发现校验标识不匹配，说明资源已经被修改或过期，浏览器需要重新获取资源内容。

## 缓存过程：

### 第一次发起 HTTP 请求：

浏览器与服务器通信的方式为应答模式，那么浏览器第一次向服务器发起请求后拿到请求结果，会根据响应报文中 HTTP 头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中。

![](/assets/第一次HTTP请求.png)

### 强制缓存：

强制缓存就是向浏览器缓存查找请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，分三种情况：

- 不存在该缓存缓存结果和缓存标识，强制缓存失效，直接向服务器发起请求
- 存在该缓存结果和缓存标识，但该结果已失效，使用协商缓存
- 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果

![](/assets/强制缓存.png)

### 强制缓存的缓存规则：

当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回浏览器，控制强制缓存的字段分别是 Expires 和 Cache-Control，其中 Cache-Control 优先级比 Expires 高。

**Expires：**HTTP/1.0 的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于 Expires 的值时，直接使用缓存结果。（HTTP/1.1，Expire 已被 Cache-Control 替代，原因是使用客户端的时间与服务端返回的时间做对比易发生误差，那么强制缓存会直接失效）。

**Cache-Control：**

Cache-Control 主要用于控制网页缓存，主要取值为：

- public：所有内容都将被缓存
- private：所有内容只有客户端可以缓存（默认值）
- no-cache：客户端缓存内容，但是否使用缓存则需要经过协商缓存来验证决定
- no-store：所有内容都不会被缓存，即不适用强制缓存，也不适用协商缓存
- max-age = xxx：缓存内容在 xxx 秒后失效

### 内存缓存（from memory cache）与硬盘缓存（from disk cache）：

**内存缓存（from memory cache）**：具有快速读取和时效性：

- 快速读取：将解释后的文件，直接存入该进程的内存中，占据该进程一定的内存资源
- 时效性：一旦进程关闭，则该进程的内存则会被清空

**硬盘缓存（from disk cache）：**将缓存直接写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行 I/O 操作，然后重新解析该缓存内如，读取速度比内存缓存慢。

在浏览器中，浏览器会在 js 和图片等文件解析执行后直接存入内存缓存中，当刷新页面时直接从内存缓存中读取；而 CSS 文件会存入硬盘文件中，所以每次渲染页面都从硬盘读取缓存。

### 协商缓存：

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。分为两种情况：

- 协商缓存生效，返回 304

![](/assets/协商缓存1.png)

- 协商缓存失效，返回 200 和请求结果

![](/assets/协商缓存2.png)

协商缓存的标识也在响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制协商缓存的字段分别为：**Last-Modified / If-Modified-Since**和**Etag / If-None-Match**，其中 Etag/If-None-Match 优先级高。

**Last-Modified / If-Modified-Since：**

- Last-Modified：服务器响应请求时，返回该资源文件在服务器最后被修改的时间

- If-Modified-Since：客户端再次发起该请求时，携带上次请求返回的 Last-Modified 值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到请求，发现请求头含有 If-Modified-Since 字段，根据其值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于 If-Modified-Since 值，则重新返回资源，状态码 200；否则返回 304，代表资源无更新，可继续使用缓存文件

**Etag / If-None-Match：**

- Etag：服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成）

- If-None-Match：客户端再次发起该请求时，携带上次请求返回的 Etag 值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有 If-None-Match，则会根据 If-None-Match 与该资源在服务器的 Etag 值做对比，一致则返回 304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码 200

## 好处：

1. 减少网络带宽消耗
2. 降低服务器压力
3. 减少网络延迟，加快网页打开速度

## 用户行为与缓存：

![](/assets/浏览器缓存.png)

## 不能缓存的请求：

1. HTTP 信息头包含 Cache-Control: no-cache, pragma: no-cache\(HTTP1.0\), Cache: max-age 等告诉浏览器不用缓存的请求
2. 根据 Cookie，认证信息等决定输入内容 的动态请求是不能被缓存
3. 经过 HTTPS 安全加密的请求
4. POST 请求无法被缓存
5. HTTP 响应头中不包含 Last-Modified/Etag, 也不包含 Cache-Control/Expires 的请求无法被缓存
